/* DO NOT EDIT THIS FILE */
/* This file is autogenerated by the text-database code generator */

#include <fonts/FontCache.hpp>
#include <fonts/CachedFont.hpp>
#include <texts/TypedTextDatabase.hpp>
#include <touchgfx/Utils.hpp>
#include <cstring>

namespace touchgfx
{
FontCache::FontCache()
    : memorySize(0), memory(0), top(0), reader(0)
{
}

void FontCache::clear()
{
    memset(memory, 0, memorySize);
    memset(fontTable, 0, sizeof(fontTable));
}

void FontCache::setMemory(uint8_t* _memory, uint32_t size)
{
    memory = _memory;
    top = memory;
    memorySize = size;

    clear();
}

void FontCache::setReader(FontDataReader* _reader)
{
    reader = _reader;
}

const GlyphNode* FontCache::getGlyph(Unicode::UnicodeChar unicode, FontId font) const
{
    GlyphNode* g = (GlyphNode*)fontTable[font].first;
    while (g)
    {
        if (g->unicode == unicode)
        {
            return g;
        }
        GlyphNode** next = (GlyphNode**)((uint8_t*)g + SizeGlyphNode);
        g = *next;
    }
    return 0;
}

void FontCache::open()
{
    if (reader)
    {
        reader->open();
    }
}

void FontCache::close()
{
    if (reader)
    {
        reader->close();
    }
}

void FontCache::initializeCachedFont(TypedText t, CachedFont* font)
{
    //get font index from typed text
    FontId fontId = t.getFontId();
    //reset to start of file
    setPosition(0);

    assert(sizeof(touchgfx::BinaryFontData) < MAX_BUFFER_SIZE);
    readData(buffer, sizeof(touchgfx::BinaryFontData));
    const Font** flashFonts = TypedTextDatabase::getFonts();
    const GeneratedFont* flashFont = static_cast<const GeneratedFont*>(flashFonts[fontId]);
    *font = CachedFont((const struct touchgfx::BinaryFontData*)buffer, fontId, this, flashFont);
}

bool FontCache::cacheString(TypedText t, const Unicode::UnicodeChar* string)
{
    //get font index from typed text
    FontId fontId = t.getFontId();
    //get BPP from standard font
    const Font* font = t.getFont();
    uint32_t bpp = font->getBitsPerPixel();
    uint32_t* data = reinterpret_cast<uint32_t*>(buffer);

    if (!createSortedString(string))
    {
        return false;
    }

    setPosition(4); //skip font index
    assert(sizeof(uint32_t) < MAX_BUFFER_SIZE);
    readData(data, sizeof(uint32_t));
    glyphNodeOffset = *data;
    readData(data, sizeof(uint32_t));
    kerningTableOffset = *data;
    readData(data, sizeof(uint32_t));
    glyphDataOffset = *data;
    readData(data, sizeof(uint32_t));
    gsubOffset = *data;
    readData(data, sizeof(uint16_t));
    numGlyphs = *data;

    //go to glyph nodes for font
    setPosition(glyphNodeOffset);
    currentFileGlyphNumber = 0;
    //toBeCachedSize = 0;
    readTooFar = false;

    string = sortedString;
    Unicode::UnicodeChar last = 0;
    GlyphNode* firstNewGlyph = 0;
    bool outOfMemory = false;
    while (*string)
    {
        Unicode::UnicodeChar ch = *string;
        if (ch != last)
        {
            if (!contains(ch, fontId))
            {
                insert(ch, fontId, bpp, outOfMemory);
                if (outOfMemory)
                {
                    break;
                }
                if (firstNewGlyph == 0)
                {
                    firstNewGlyph = (GlyphNode*)fontTable[fontId].last;
                }
            }
        }
        last = ch;
        string++;
    }

    cacheData(bpp, firstNewGlyph);
    return !outOfMemory;
}

bool FontCache::contains(Unicode::UnicodeChar unicode, FontId font) const
{
    GlyphNode* g = (GlyphNode*)fontTable[font].first;
    while (g)
    {
        if (g->unicode == unicode)
        {
            return true;
        }
        GlyphNode** next = (GlyphNode**)((uint8_t*)g + SizeGlyphNode);
        g = *next;
    }
    return false;
}

void FontCache::insert(Unicode::UnicodeChar unicode, FontId font, uint32_t bpp, bool& outOfMemory)
{
    //insert new glyphnode and glyph after last for font.
    uint8_t* oldTop = top;
    top = copyGlyph(top, unicode, font, bpp, outOfMemory);

    if (top == oldTop)
    {
        return;
    }

    if (fontTable[font].last == 0)
    {
        //first glyph
        fontTable[font].first = oldTop;
        fontTable[font].last = oldTop;
    }
    else
    {
        //set next pointer of old last glyph
        uint8_t** old_next = (uint8_t**)(fontTable[font].last + SizeGlyphNode);
        *old_next = oldTop;

        //save new glyph as last glyph
        fontTable[font].last = oldTop;
    }
}

uint8_t* FontCache::copyGlyph(uint8_t* top, Unicode::UnicodeChar unicode, FontId font, uint32_t bpp, bool& outOfMemory)
{
    while (currentFileGlyphNumber < numGlyphs)
    {
        if (!readTooFar)
        {
            readData(&currentFileGlyphNode, sizeof(GlyphNode));
            currentFileGlyphNumber++;
        }
        else
        {
            readTooFar = false;
        }
        if (currentFileGlyphNode.unicode == unicode)
        {
            break;
        }
        else if (currentFileGlyphNode.unicode > unicode)
        {
            //glyph not found
            readTooFar = true;
            return top;
        }
    }

    //glyph not found
    if (currentFileGlyphNode.unicode != unicode)
    {
        return top;
    }

    //glyphnode found;
    uint32_t glyphSize = ((currentFileGlyphNode.width() + 1) & ~1) * currentFileGlyphNode.height() * bpp / 8;
    glyphSize = (glyphSize + 3) & ~0x03;

    //is space available before sortedString
    if (top + SizeGlyphNode + 4 + glyphSize > (uint8_t*)sortedString)
    {
        outOfMemory = true;
        return top;
    }

    *(GlyphNode*)top = currentFileGlyphNode;

    top += SizeGlyphNode;
    //next pointer zero
    top += 4;

    //increase top to reserve spacer for deferred copying
    top += glyphSize;
    return top;
}

void FontCache::cacheData(uint32_t bpp, GlyphNode* first)
{
    GlyphNode* gn = first;
    while (gn)
    {
        uint8_t* p = (uint8_t*)gn;
        if(gn->dataOffset != 0xFFFFFFFF)
        {
            p += SizeGlyphNode;
            //next pointer
            p += 4;

            //seek and copy
            setPosition(glyphDataOffset + gn->dataOffset);
            uint32_t glyphSize = ((gn->width() + 1) & ~1) * gn->height() * bpp / 8;
            readData(p, glyphSize);

            //mark glyphNode as cached
            gn->dataOffset = 0xFFFFFFFF;
        }

        GlyphNode** next = (GlyphNode**)((uint8_t*)gn + SizeGlyphNode);
        gn = *next;
    }
}

bool FontCache::createSortedString(const Unicode::UnicodeChar* string)
{
    int length = Unicode::strlen(string);
    //sorted string is allocated at end of buffer
    sortedString = (Unicode::UnicodeChar*)(memory + memorySize - (length + 1) * 2);
    if ((uint8_t*)sortedString < top)
    {
        //unable to allocate string buffer in end of memory
        return false;
    }
    int n = 0;
    Unicode::UnicodeChar* uc = sortedString;
    while (*string)
    {
        *uc++ = *string++;
        n++;
    }
    *uc = 0;

    uc = sortedString;
    int i, j;
    bool swapped;
    for (i = 0; i < n - 1; i++)
    {
        swapped = false;
        for (j = 0; j < n - i - 1; j++)
        {
            if (uc[j] > uc[j + 1])
            {
                Unicode::UnicodeChar temp = uc[j];
                uc[j] = uc[j + 1];
                uc[j + 1] = temp;
                swapped = true;
            }
        }

        //if no two elements were swapped by inner loop, then break
        if (swapped == false)
        {
            break;
        }
    }
    return true;
}

void FontCache::setPosition(uint32_t position)
{
    if (reader)
    {
        reader->setPosition(position);
    }
}

void FontCache::readData(void* out, uint32_t numberOfBytes)
{
    if (reader)
    {
        reader->readData(out, numberOfBytes);
    }
}
} // namespace touchgfx
